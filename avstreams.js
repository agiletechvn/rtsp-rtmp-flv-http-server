// Generated by CoffeeScript 2.5.1
(function() {
  var AVStream,
    AVStreamGenerator,
    Bits,
    EventEmitterModule,
    MP4Stream,
    aac,
    api,
    createStreamId,
    crypto,
    eventListeners,
    fs,
    h264,
    logger,
    mp4,
    path,
    recordedAppToDir,
    streamGenerators,
    streams,
    splice = [].splice;

  crypto = require("crypto");

  fs = require("fs");

  path = require("path");

  h264 = require("./h264");

  aac = require("./aac");

  mp4 = require("./mp4");

  Bits = require("./bits");

  EventEmitterModule = require("./event_emitter");

  logger = require("./logger");

  createStreamId = function() {
    var buf, e, shasum;
    try {
      buf = crypto.randomBytes(256);
    } catch (error) {
      e = error;
      logger.error(`crypto.randomBytes() failed: ${e}`);
      buf = crypto.pseudoRandomBytes(256);
    }
    shasum = crypto.createHash("sha512");
    shasum.update(buf);
    return shasum.digest("hex").slice(0, 8);
  };

  // Generates stream upon request
  AVStreamGenerator = class AVStreamGenerator {
    constructor(methods) {
      if ((methods != null ? methods.generate : void 0) != null) {
        this.generate = methods.generate;
      }
      if ((methods != null ? methods.teardown : void 0) != null) {
        this.teardown = methods.teardown;
      }
      if ((methods != null ? methods.pause : void 0) != null) {
        this.pause = methods.pause;
      }
      if ((methods != null ? methods.resume : void 0) != null) {
        this.resume = methods.resume;
      }
      if ((methods != null ? methods.seek : void 0) != null) {
        this.seek = methods.seek;
      }
      if (
        (methods != null
          ? methods.sendVideoPacketsSinceLastKeyFrame
          : void 0) != null
      ) {
        this.sendVideoPacketsSinceLastKeyFrame =
          methods.sendVideoPacketsSinceLastKeyFrame;
      }
      if ((methods != null ? methods.getCurrentPlayTime : void 0) != null) {
        this.getCurrentPlayTime = methods.getCurrentPlayTime;
      }
      if ((methods != null ? methods.isPaused : void 0) != null) {
        this.isPaused = methods.isPaused;
      }
      if (methods != null) {
        if (typeof methods.init === "function") {
          methods.init();
        }
      }
    }

    generate() {}

    teardown() {}
  };

  AVStream = class AVStream extends EventEmitterModule {
    constructor(id) {
      super();
      this.id = id; // string
      this.initAVParams();
    }

    initAVParams() {
      this.audioClockRate = null; // int
      this.audioSampleRate = null; // int
      this.audioChannels = null; // int
      this.audioPeriodSize = 1024; // TODO: detect this from stream?
      this.audioObjectType = null; // int
      this.videoWidth = null; // int
      this.videoHeight = null; // int
      this.videoProfileLevelId = null; // string (e.g. '42C01F')
      this.videoFrameRate = 30.0; // float  # TODO: default value
      this.videoAVCLevel = null; // int
      this.videoAVCProfile = null; // int
      this.isVideoStarted = false; // boolean
      this.isAudioStarted = false; // boolean
      this.timeAtVideoStart = null; // milliseconds since the epoch
      this.timeAtAudioStart = null; // milliseconds since the epoch
      this.spsString = ""; // string
      this.ppsString = ""; // string
      this.spsNALUnit = null; // buffer
      this.ppsNALUnit = null; // buffer
      this.spropParameterSets = ""; // string
      return (this.type = null); // string ('live' or 'recorded')
    }

    destroy() {
      logger.debug(`[stream:${this.id}] destroy`);
      this.spsNALUnit = null;
      this.ppsNALUnit = null;
      return this.emit("destroy");
    }

    isRecorded() {
      return this.type === api.STREAM_TYPE_RECORDED;
    }

    reset() {
      logger.debug(`[stream:${this.id}] reset`);
      this.initAVParams();
      return this.emit("reset");
    }

    updateSpropParam(buf) {
      var nalUnitType;
      nalUnitType = buf[0] & 0x1f;
      if (nalUnitType === 7) {
        // SPS packet
        this.spsString = buf.toString("base64");
        this.videoProfileLevelId = buf
          .slice(1, 4)
          .toString("hex")
          .toUpperCase();
      } else if (nalUnitType === 8) {
        // PPS packet
        this.ppsString = buf.toString("base64");
      }
      return (this.spropParameterSets = this.spsString + "," + this.ppsString);
    }

    resetFrameRate() {
      this.frameRateCalcBasePTS = null;
      this.frameRateCalcNumFrames = null;
      return (this.videoFrameRate = 30.0); // TODO: What value should we use as a default frame rate?
    }

    calcFrameRate(pts) {
      var diffMs, frameRate;
      if (this.frameRateCalcBasePTS != null) {
        diffMs = (pts - this.frameRateCalcBasePTS) / 90;
        if (pts !== this.lastPTS) {
          this.frameRateCalcNumFrames++;
          this.lastPTS = pts;
        }
        if (this.frameRateCalcNumFrames >= 150 || diffMs >= 5000) {
          frameRate = (this.frameRateCalcNumFrames * 1000) / diffMs;
          if (frameRate !== this.videoFrameRate) {
            logger.debug(
              `[stream:${this.id}] frame rate: ${this.videoFrameRate}`
            );
            this.videoFrameRate = frameRate;
            this.emit("update_frame_rate", frameRate);
          }
          this.frameRateCalcBasePTS = pts;
          this.frameRateCalcNumFrames = 0;
          return (this.lastPTS = null);
        }
      } else {
        this.frameRateCalcBasePTS = pts;
        this.frameRateCalcNumFrames = 0;
        return (this.lastPTS = null);
      }
    }

    updateConfig(obj) {
      var isConfigUpdated, name, value;
      isConfigUpdated = false;
      for (name in obj) {
        value = obj[name];
        if (this[name] !== value) {
          this[name] = value;
          if (value instanceof Buffer) {
            logger.debug(
              `[stream:${this.id}] update ${name}: Buffer=<0x${value.toString(
                "hex"
              )}>`
            );
          } else if (typeof value === "object") {
            logger.debug(`[stream:${this.id}] update ${name}:`);
            logger.debug(value);
          } else {
            logger.debug(`[stream:${this.id}] update ${name}: ${value}`);
          }
          if (name === "audioASCInfo") {
            if ((value != null ? value.sbrPresentFlag : void 0) === 1) {
              if ((value != null ? value.psPresentFlag : void 0) === 1) {
                logger.debug(`[stream:${this.id}] audio: HE-AAC v2`);
              } else {
                logger.debug(`[stream:${this.id}] audio: HE-AAC v1`);
              }
            }
          }
          isConfigUpdated = true;
        }
      }
      if (isConfigUpdated) {
        return this.emit("updateConfig");
      }
    }

    // nal_unit_type 7
    updateSPS(nalUnit) {
      var e, frameSize, isConfigUpdated, sps;
      if (this.spsNALUnit == null || nalUnit.compare(this.spsNALUnit) !== 0) {
        this.spsNALUnit = nalUnit;
        this.updateSpropParam(nalUnit);
        try {
          sps = h264.readSPS(nalUnit);
        } catch (error) {
          e = error;
          logger.error(
            `[stream:${this.id}] video data error: failed to read SPS`
          );
          logger.error(e.stack);
          return;
        }
        frameSize = h264.getFrameSize(sps);
        isConfigUpdated = false;
        if (this.videoWidth !== frameSize.width) {
          this.videoWidth = frameSize.width;
          logger.debug(`[stream:${this.id}] video width: ${this.videoWidth}`);
          isConfigUpdated = true;
        }
        if (this.videoHeight !== frameSize.height) {
          this.videoHeight = frameSize.height;
          logger.debug(`[stream:${this.id}] video height: ${this.videoHeight}`);
          isConfigUpdated = true;
        }
        if (this.videoAVCLevel !== sps.level_idc) {
          this.videoAVCLevel = sps.level_idc;
          logger.debug(
            `[stream:${this.id}] video avclevel: ${this.videoAVCLevel}`
          );
          isConfigUpdated = true;
        }
        if (this.videoAVCProfile !== sps.profile_idc) {
          this.videoAVCProfile = sps.profile_idc;
          logger.debug(
            `[stream:${this.id}] video avcprofile: ${this.videoAVCProfile}`
          );
          isConfigUpdated = true;
        }
        if (isConfigUpdated) {
          logger.debug(
            `[stream:${this.id}] updated SPS: 0x${nalUnit.toString("hex")}`
          );
          return this.emit("updateConfig");
        }
      }
    }

    // nal_unit_type 8
    updatePPS(nalUnit) {
      if (this.ppsNALUnit == null || nalUnit.compare(this.ppsNALUnit) !== 0) {
        logger.debug(
          `[stream:${this.id}] updated PPS: 0x${nalUnit.toString("hex")}`
        );
        this.ppsNALUnit = nalUnit;
        this.updateSpropParam(nalUnit);
        return this.emit("updateConfig");
      }
    }

    toString() {
      var str;
      str = `${this.id}: `;
      if (this.videoWidth != null) {
        str += `video: ${this.videoWidth}x${this.videoHeight} profile=${this.videoAVCProfile} level=${this.videoAVCLevel}`;
      } else {
        str += "video: (waiting for data)";
      }
      if (this.audioSampleRate != null) {
        str += `; audio: samplerate=${this.audioSampleRate} channels=${this.audioChannels} objecttype=${this.audioObjectType}`;
      } else {
        str += "; audio: (waiting for data)";
      }
      return str;
    }
  };

  MP4Stream = class MP4Stream extends AVStream {
    static create(filename) {
      var ascBuf, ascInfo, bits, err, mp4File, mp4Stream, streamId;
      try {
        mp4File = new mp4.MP4File(filename);
      } catch (error) {
        err = error;
        logger.error(`error opening MP4 file ${filename}: ${err}`);
        return null;
      }
      streamId = api.createNewStreamId();
      mp4Stream = new MP4Stream(streamId);
      logger.debug(`created stream ${streamId} from file ${filename}`);
      api.emit("new", mp4Stream);
      api.add(mp4Stream);
      mp4Stream.type = api.STREAM_TYPE_RECORDED;
      mp4File.on("audio_data", function(data, pts) {
        return mp4Stream.emit("audio_data", data, pts);
      });
      mp4File.on("video_data", function(nalUnits, pts, dts) {
        return mp4Stream.emit("video_data", nalUnits, pts, dts);
      });
      mp4File.on("eof", function() {
        return mp4Stream.emit("end");
      });
      mp4File.parse();
      if (mp4File.hasVideo()) {
        mp4Stream.updateSPS(mp4File.getSPS());
        mp4Stream.updatePPS(mp4File.getPPS());
      }
      if (mp4File.hasAudio()) {
        ascBuf = mp4File.getAudioSpecificConfig();
        bits = new Bits(ascBuf);
        ascInfo = aac.readAudioSpecificConfig(bits);
        mp4Stream.updateConfig({
          audioSpecificConfig: ascBuf,
          audioASCInfo: ascInfo,
          audioSampleRate: ascInfo.samplingFrequency,
          audioClockRate: 90000,
          audioChannels: ascInfo.channelConfiguration,
          audioObjectType: ascInfo.audioObjectType
        });
      }
      mp4Stream.durationSeconds = mp4File.getDurationSeconds();
      mp4Stream.lastTagTimestamp = mp4File.getLastTimestamp();
      mp4Stream.mp4File = mp4File;
      mp4File.fillBuffer(function() {
        if (mp4File.hasAudio()) {
          mp4Stream.emit("audio_start");
          mp4Stream.isAudioStarted = true;
        }
        if (mp4File.hasVideo()) {
          mp4Stream.emit("video_start");
          return (mp4Stream.isVideoStarted = true);
        }
      });
      return mp4Stream;
    }

    play() {
      return this.mp4File.play();
    }

    pause() {
      return this.mp4File.pause();
    }

    resume() {
      return this.mp4File.resume();
    }

    seek(seekSeconds, callback) {
      var actualStartTime;
      actualStartTime = this.mp4File.seek(seekSeconds);
      return callback(null, actualStartTime);
    }

    sendVideoPacketsSinceLastKeyFrame(endSeconds, callback) {
      return this.mp4File.sendVideoPacketsSinceLastKeyFrame(
        endSeconds,
        callback
      );
    }

    teardown() {
      logger.debug(`[mp4stream:${this.id}] teardown`);
      this.mp4File.close();
      return this.destroy();
    }

    getCurrentPlayTime() {
      return this.mp4File.currentPlayTime;
    }

    isPaused() {
      return this.mp4File.isPaused();
    }
  };

  eventListeners = {};

  streams = {};

  streamGenerators = {};

  recordedAppToDir = {};

  api = {
    STREAM_TYPE_LIVE: "live",
    STREAM_TYPE_RECORDED: "recorded",
    AVStream: AVStream,
    MP4Stream: MP4Stream,
    AVStreamGenerator: AVStreamGenerator,
    emit: function(name, ...data) {
      var j, len, listener, ref;
      if (eventListeners[name] != null) {
        ref = eventListeners[name];
        for (j = 0, len = ref.length; j < len; j++) {
          listener = ref[j];
          listener(...data);
        }
      }
    },
    on: function(name, listener) {
      if (eventListeners[name] != null) {
        return eventListeners[name].push(listener);
      } else {
        return (eventListeners[name] = [listener]);
      }
    },
    removeListener: function(name, listener) {
      var _listener, i, j, len, ref, ref1;
      if (eventListeners[name] != null) {
        ref = eventListeners[name];
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          _listener = ref[i];
          if (_listener === listener) {
            splice.apply(eventListeners, [i, i - i + 1].concat((ref1 = []))),
              ref1;
          }
        }
      }
    },
    getAll: function() {
      return streams;
    },
    exists: function(streamId) {
      return streams[streamId] != null;
    },
    get: function(streamId) {
      var app, dir, e, filename, filetype, match, pathSep, stream;
      if (streams[streamId] != null) {
        return streams[streamId];
      } else if (streamGenerators[streamId] != null) {
        stream = streamGenerators[streamId].generate();
        if (stream != null) {
          stream.teardown = streamGenerators[streamId].teardown;
          stream.pause = streamGenerators[streamId].pause;
          stream.resume = function() {
            stream.resetFrameRate();
            return streamGenerators[streamId].resume.apply(this, arguments);
          };
          stream.seek = function() {
            stream.resetFrameRate();
            return streamGenerators[streamId].seek.apply(this, arguments);
          };
          stream.getCurrentPlayTime =
            streamGenerators[streamId].getCurrentPlayTime;
          stream.sendVideoPacketsSinceLastKeyFrame =
            streamGenerators[streamId].sendVideoPacketsSinceLastKeyFrame;
          stream.isPaused = streamGenerators[streamId].isPaused;
          logger.debug(`created stream ${stream.id}`);
        }
        return stream; // recorded dir
      } else {
        for (app in recordedAppToDir) {
          dir = recordedAppToDir[app];
          if (streamId.slice(0, +app.length + 1 || 9e9) === app + "/") {
            filename = streamId.slice(app.length + 1);
            // Strip "filetype:" from "filetype:filename"
            if ((match = /^(\w*?):(.*)$/.exec(filename)) != null) {
              filetype = match[1];
              filename = match[2];
            } else {
              filetype = "mp4"; // default extension
            }
            filename = path.normalize(filename);
            // Check that filename is legitimate
            pathSep = path.sep;
            if (pathSep === "\\") {
              // Windows
              pathSep = "\\" + pathSep; // Escape '\' for regex
            }
            if (
              filename === "." ||
              new RegExp(`(^|${pathSep})..(${pathSep}|$)`).test(filename)
            ) {
              logger.warn(`rejected request to stream: ${streamId}`);
              break;
            }
            try {
              fs.accessSync(`${dir}/${filename}`, fs.R_OK);
            } catch (error) {
              e = error;
              try {
                // Add extension to the end and try again
                fs.accessSync(`${dir}/${filename}.${filetype}`, fs.R_OK);
                filename = `${filename}.${filetype}`;
              } catch (error) {
                e = error;
                logger.error(
                  `error: failed to read ${dir}/${filename} or ${dir}/${filename}.${filetype}: ${e}`
                );
                return null;
              }
            }
            stream = MP4Stream.create(`${dir}/${filename}`);
            logger.info(`created stream ${stream.id} from ${dir}/${filename}`);
            return stream;
          }
        }
        return null;
      }
    },
    attachRecordedDirToApp: function(dir, appName) {
      if (recordedAppToDir[appName] != null) {
        logger.warn(
          `warning: avstreams.attachRecordedDirToApp: overwriting existing app: ${appName}`
        );
      }
      return (recordedAppToDir[appName] = dir);
    },
    addGenerator: function(streamId, generator) {
      if (streamGenerators[streamId] != null) {
        logger.warn(
          `warning: avstreams.addGenerator(): overwriting generator: ${streamId}`
        );
      }
      return (streamGenerators[streamId] = generator);
    },
    removeGenerator: function(streamId) {
      if (streamGenerators[streamId] != null) {
        streamGenerators[streamId].teardown();
      }
      return delete streamGenerators[streamId];
    },
    createNewStreamId: function() {
      var id, retryCount;
      retryCount = 0;
      while (true) {
        id = createStreamId();
        if (!api.exists(id)) {
          return id;
        }
        retryCount++;
        if (retryCount >= 100) {
          throw new Error(
            "avstreams.createNewStreamId: Failed to create new stream id"
          );
        }
      }
    },
    // Creates a new stream.
    // If streamId is not given, a unique id will be generated.
    create: function(streamId) {
      var stream;
      if (streamId == null) {
        streamId = api.createNewStreamId();
      }
      stream = new AVStream(streamId);
      logger.debug(`created stream ${streamId}`);
      api.emit("new", stream);
      api.add(stream);
      return stream;
    },
    getOrCreate: function(streamId) {
      var stream;
      stream = streams[streamId];
      if (stream == null) {
        stream = api.create(streamId);
      }
      return stream;
    },
    add: function(stream) {
      if (streams[stream.id] != null) {
        logger.warn(`warning: overwriting stream: ${stream.id}`);
      }
      streams[stream.id] = stream;
      api.emit("add_stream", stream);
      stream._onAnyListener = (function(stream) {
        return function(eventName, ...data) {
          api.emit(eventName, stream, ...data);
          if (eventName === "destroy") {
            return api.remove(stream.id);
          }
        };
      })(stream);
      return stream.onAny(stream._onAnyListener);
    },
    remove: function(streamId) {
      var stream;
      if (typeof streamId === "object") {
        // streamId argument might be stream object
        stream = streamId;
        streamId = stream != null ? stream.id : void 0;
      } else {
        stream = streams[streamId];
      }
      if (stream != null) {
        stream.offAny(stream._onAnyListener);
        api.emit("remove_stream", stream);
      }
      return delete streams[streamId];
    },
    clear: function() {
      streams = {};
      return api.emit("clear_streams");
    },
    dump: function() {
      var results, stream, streamId;
      logger.raw(`[streams: ${Object.keys(streams).length}]`);
      results = [];
      for (streamId in streams) {
        stream = streams[streamId];
        results.push(logger.raw(" " + stream.toString()));
      }
      return results;
    }
  };

  module.exports = api;
}.call(this));
