// Generated by CoffeeScript 2.5.1
(function() {
  var FRAGMENT_HEADER_LEN,
    INITIAL_PACKET_ID,
    MAX_PACKET_ID,
    OLD_UDP_PACKET_TIME_THRESHOLD,
    PACKET_TYPE_ACK,
    PACKET_TYPE_REQUIRE_ACK,
    PACKET_TYPE_RESET,
    PACKET_TYPE_UNRELIABLE,
    RECEIVE_PACKET_ID_WINDOW,
    RESEND_TIMEOUT,
    UDPClient,
    UDPServer,
    dgram,
    events,
    logger,
    zeropad;

  events = require("events");

  dgram = require("dgram");

  logger = require("./logger");

  MAX_PACKET_ID = 255;

  FRAGMENT_HEADER_LEN = 2;

  RESEND_TIMEOUT = 100; // ms

  PACKET_TYPE_UNRELIABLE = 0x01;

  PACKET_TYPE_REQUIRE_ACK = 0x02;

  PACKET_TYPE_ACK = 0x03;

  PACKET_TYPE_RESET = 0x04;

  OLD_UDP_PACKET_TIME_THRESHOLD = 1000;

  RECEIVE_PACKET_ID_WINDOW = 10;

  INITIAL_PACKET_ID = 0;

  zeropad = function(width, num) {
    num += "";
    while (num.length < width) {
      num = "0" + num;
    }
    return num;
  };

  exports.UDPClient = UDPClient = class UDPClient {
    constructor() {
      this.pendingPackets = [];
      this.newPacketId = 0;
      this.maxPacketSize = 8000; // good for LAN?
      //    @maxPacketSize = 1472  # good for internet
      this.isInBlockMode = false;
      this.ackCallbacks = {};
      this.serverPort = null;
      this.serverHost = null;
      this.isStopped = false;
      this.socket = dgram.createSocket("udp4");
      this.socket.on("error", function(err) {
        logger.error(`UDPServer socket error: ${err}`);
        return this.socket.close();
      });
      this.socket.on("message", (msg, rinfo) => {
        return this.onMessage(msg, rinfo);
      });
    }

    start(serverPort, serverHost, callback) {
      this.serverPort = serverPort;
      this.serverHost = serverHost;
      // bind to any available port
      return this.socket.bind(0, "0.0.0.0", () => {
        return this.resetPacketId(callback);
      });
    }

    stop() {
      this.isStopped = true;
      return this.socket.close();
    }

    onMessage(msg, rinfo) {
      var packetId, packetType;
      packetType = msg[0];
      if (packetType === PACKET_TYPE_ACK) {
        packetId = msg[1];
        if (this.ackCallbacks[packetId] != null) {
          return this.ackCallbacks[packetId]();
        } else {
          return logger.warn(
            `ACK is already processed for packetId ${packetId}`
          );
        }
      } else {
        logger.warn(`unknown packet type: ${packetType} len=${msg.length}`);
        return logger.warn(msg);
      }
    }

    getNextPacketId() {
      var id;
      id = this.newPacketId;
      if (++this.newPacketId > MAX_PACKET_ID) {
        this.newPacketId = 0;
      }
      return id;
    }

    sendPacket(packetType, packetId, buf, callback) {
      var bufLen,
        endFragmentNumber,
        fragmentNumber,
        fragmentSize,
        sendData,
        sendNextFragment,
        sentCount,
        totalFragments,
        wroteLen;
      sendData = Buffer.from(this.maxPacketSize);
      sendData[0] = packetType;
      sendData[1] = packetId;
      fragmentSize = this.maxPacketSize - FRAGMENT_HEADER_LEN - 2;
      if (fragmentSize <= 0) {
        throw new Error(`maxPacketSize must be > ${FRAGMENT_HEADER_LEN + 2}`);
      }
      bufLen = buf.length;
      totalFragments = Math.ceil(bufLen / fragmentSize);
      // maximum number of fragments is 256
      if (totalFragments > 256) {
        throw new Error(
          `too many fragments: ${totalFragments} (buf.length=${bufLen} / fragmentSize=${fragmentSize})`
        );
      }
      endFragmentNumber = totalFragments - 1;
      sendData[2] = endFragmentNumber;
      fragmentNumber = 0;
      wroteLen = 0;
      sentCount = 0;
      sendNextFragment = () => {
        var remainingLen, thisLen;
        if (wroteLen >= bufLen) {
          throw new Error(`wroteLen (${wroteLen}) > bufLen (${bufLen})`);
        }
        remainingLen = bufLen - wroteLen;
        if (remainingLen < fragmentSize) {
          thisLen = remainingLen;
        } else {
          thisLen = fragmentSize;
        }
        sendData[3] = fragmentNumber;
        buf.copy(sendData, 4, wroteLen, wroteLen + thisLen);
        fragmentNumber++;
        return this.socket.send(
          sendData,
          0,
          thisLen + 4,
          this.serverPort,
          this.serverHost,
          () => {
            wroteLen += thisLen;
            sentCount++;
            if (sentCount === totalFragments) {
              return typeof callback === "function" ? callback() : void 0;
            } else {
              return sendNextFragment();
            }
          }
        );
      };
      return sendNextFragment();
    }

    resetPacketId(callback) {
      var buf, isACKReceived;
      buf = Buffer.from([
        // packet type
        PACKET_TYPE_RESET,
        // packet id
        INITIAL_PACKET_ID
      ]);
      this.newPacketId = INITIAL_PACKET_ID + 1;
      isACKReceived = false;
      // wait until receives ack
      this.waitForACK(INITIAL_PACKET_ID, function() {
        isACKReceived = true;
        return typeof callback === "function" ? callback() : void 0;
      });
      // send
      this.socket.send(buf, 0, buf.length, this.serverPort, this.serverHost);
      return setTimeout(() => {
        if (!isACKReceived && !this.isStopped) {
          logger.warn("resend reset (no ACK received)");
          return this.resetPacketId(callback);
        }
      }, RESEND_TIMEOUT);
    }

    rawSend(buf, offset, length, callback) {
      return this.socket.send(
        buf,
        offset,
        length,
        this.serverPort,
        this.serverAddress,
        callback
      );
    }

    write(buf, callback) {
      var packetId;
      if (this.isInBlockMode) {
        this.pendingPackets.push([this.write, ...arguments]);
        return;
      }
      packetId = this.getNextPacketId();
      return this.sendPacket(PACKET_TYPE_UNRELIABLE, packetId, buf, callback);
    }

    _writeReliableBypassBlock(
      buf,
      packetId,
      onSuccessCallback,
      onTimeoutCallback
    ) {
      var isACKReceived;
      isACKReceived = false;
      // wait until receives ack
      this.waitForACK(packetId, function() {
        isACKReceived = true;
        return typeof onSuccessCallback === "function"
          ? onSuccessCallback()
          : void 0;
      });
      // send
      this.sendPacket(PACKET_TYPE_REQUIRE_ACK, packetId, buf);
      return setTimeout(() => {
        if (!isACKReceived && !this.isStopped) {
          logger.warn(`resend ${packetId} (no ACK received)`);
          return onTimeoutCallback();
        }
      }, RESEND_TIMEOUT);
    }

    _writeReliable(buf, packetId, callback) {
      if (this.isInBlockMode) {
        this.pendingPackets.push([this._writeReliable, ...arguments]);
        return;
      }
      // TODO: limit maximum number of pending packets
      return this._writeReliableBypassBlock(buf, packetId, callback, () => {
        return this._writeReliable(buf, packetId, callback);
      });
    }

    writeReliable(buf, callback) {
      var packetId;
      packetId = this.getNextPacketId();
      return this._writeReliable(buf, packetId, callback);
    }

    waitForACK(packetId, callback) {
      return (this.ackCallbacks[packetId] = () => {
        delete this.ackCallbacks[packetId];
        return typeof callback === "function" ? callback() : void 0;
      });
    }

    flushPendingPackets(callback) {
      var args, func, origCallback, packet;
      if (this.pendingPackets.length === 0) {
        if (typeof callback === "function") {
          callback();
        }
        return;
      }
      packet = this.pendingPackets.shift();
      func = packet[0];
      args = packet.slice(1);
      origCallback = args[func.length - 1];
      args[func.length - 1] = () => {
        this.flushPendingPackets(callback);
        return typeof origCallback === "function" ? origCallback() : void 0;
      };
      return func.apply(this, args);
    }

    _writeReliableBlocked(buf, packetId, callback) {
      return this._writeReliableBypassBlock(buf, packetId, callback, () => {
        return this._writeReliableBlocked(buf, packetId, callback);
      });
    }

    // Defer other packets until this packet is received
    writeReliableBlocked(buf, callback) {
      var packetId;
      if (this.isInBlockMode) {
        this.pendingPackets.push([this.writeReliableBlocked, ...arguments]);
        return;
      }
      this.isInBlockMode = true;
      packetId = this.getNextPacketId();
      return this._writeReliableBlocked(buf, packetId, () => {
        this.isInBlockMode = false;
        return this.flushPendingPackets(callback);
      });
    }

    fragment(buf, fragmentSize = maxPacketSize) {
      var fragments, remainingLen, thisLen;
      fragments = [];
      remainingLen = buf.length;
      while (remainingLen > 0) {
        if (remainingLen < fragmentSize) {
          thisLen = remainingLen;
        } else {
          thisLen = fragmentSize;
        }
        fragments.push(buf.slice(0, thisLen));
        buf = buf.slice(thisLen);
      }
      return fragments;
    }
  };

  exports.UDPServer = UDPServer = class UDPServer extends events.EventEmitter {
    constructor() {
      super();
      this.socket = dgram.createSocket("udp4");
      this.socket.on("error", function(err) {
        logger.error(`UDPServer socket error: ${err}`);
        return this.socket.close();
      });
      this.socket.on("message", (msg, rinfo) => {
        return this.onReceiveMessage(msg, rinfo);
      });
      this.isStopped = false;
      this.resetServerState();
    }

    resetServerState() {
      this.videoReceiveBuf = {};
      this.processedPacketId = null;
      this.latestPacketId = null;
      this.bufferedPackets = {};
      return (this.packetLastReceiveTime = {});
    }

    onReceiveMessage(msg, rinfo) {
      var e,
        endFragmentNumber,
        fragmentNumber,
        i,
        isMissing,
        j,
        packetId,
        packetType,
        receivedBuf,
        ref,
        targetBuf;
      packetType = msg[0];
      packetId = msg[1];
      endFragmentNumber = msg[2];
      fragmentNumber = msg[3];
      if (packetType === PACKET_TYPE_RESET) {
        this.resetServerState();
        this.latestPacketId = packetId;
        this.processedPacketId = packetId;
        this.sendAck(packetId, rinfo.port, rinfo.address);
        return;
      }
      this.packetLastReceiveTime[packetId] = Date.now();
      if (this.latestPacketId != null) {
        if (
          (packetId <= this.latestPacketId + RECEIVE_PACKET_ID_WINDOW &&
            packetId > this.latestPacketId) ||
          packetId < this.latestPacketId - 50
        ) {
          this.latestPacketId = packetId;
        }
      } else {
        this.latestPacketId = packetId;
      }
      if (endFragmentNumber > 0) {
        // fragmentation
        if (this.videoReceiveBuf[packetId] != null) {
          // check if existing packet is too old
          if (
            Date.now() - this.videoReceiveBuf[packetId].time >=
            OLD_UDP_PACKET_TIME_THRESHOLD
          ) {
            logger.warn(`drop stale buffer of packetId ${packetId}`);
            this.videoReceiveBuf[packetId] = null;
          }
        }
        if (this.videoReceiveBuf[packetId] == null) {
          this.videoReceiveBuf[packetId] = {
            buf: [],
            totalReceivedLength: 0
          };
        }
        targetBuf = this.videoReceiveBuf[packetId];
        targetBuf.buf[fragmentNumber] = msg.slice(4);
        targetBuf.time = Date.now();
        targetBuf.totalReceivedLength += msg.length - 4;
        isMissing = false;
        for (
          i = j = 0, ref = endFragmentNumber;
          0 <= ref ? j <= ref : j >= ref;
          i = 0 <= ref ? ++j : --j
        ) {
          if (targetBuf.buf[i] == null) {
            isMissing = true;
            break;
          }
        }
        if (!isMissing) {
          // received all fragments
          try {
            receivedBuf = Buffer.concat(targetBuf.buf);
            return this.onReceivePacket({
              packetType: packetType,
              packetId: packetId,
              port: rinfo.port,
              address: rinfo.address,
              body: receivedBuf
            });
          } catch (error) {
            e = error;
            logger.error(`concat/receive error for packetId=${packetId}: ${e}`);
            logger.error(e.stack);
            return logger.error(targetBuf.buf);
          } finally {
            delete this.videoReceiveBuf[packetId];
            delete this.packetLastReceiveTime[packetId];
          }
        }
      } else {
        receivedBuf = msg.slice(4);
        delete this.videoReceiveBuf[packetId];
        delete this.packetLastReceiveTime[packetId];
        return this.onReceivePacket({
          packetType: packetType,
          packetId: packetId,
          port: rinfo.port,
          address: rinfo.address,
          body: receivedBuf
        });
      }
    }

    consumeBufferedPacketsFrom(packetId) {
      var oldEnoughTime;
      oldEnoughTime = Date.now() - OLD_UDP_PACKET_TIME_THRESHOLD;
      while (true) {
        if (this.bufferedPackets[packetId] == null) {
          break;
        }
        if (this.packetLastReceiveTime[packetId] <= oldEnoughTime) {
          logger.warn(`packet ${packetId} is too old`);
          break;
        }
        this.onCompletePacket(this.bufferedPackets[packetId]);
        delete this.bufferedPackets[packetId];
        this.processedPacketId = packetId;
        if (packetId === MAX_PACKET_ID) {
          packetId = 0;
        } else {
          packetId++;
        }
      }
    }

    deleteOldBufferedPackets() {
      var isDoneSomething,
        j,
        nextPacketId,
        oldEnoughTime,
        oldestUnprocessedPacketId,
        packetId,
        ref,
        ref1,
        timeDiff;
      if (this.processedPacketId === this.latestPacketId) {
        return;
      }
      isDoneSomething = false;
      if (this.processedPacketId === MAX_PACKET_ID) {
        oldestUnprocessedPacketId = 0;
      } else {
        oldestUnprocessedPacketId = this.processedPacketId + 1;
      }
      oldEnoughTime = Date.now() - OLD_UDP_PACKET_TIME_THRESHOLD;
      for (
        packetId = j = ref = oldestUnprocessedPacketId,
          ref1 = this.latestPacketId;
        ref <= ref1 ? j < ref1 : j > ref1;
        packetId = ref <= ref1 ? ++j : --j
      ) {
        if (this.packetLastReceiveTime[packetId] == null) {
          this.packetLastReceiveTime[packetId] = Date.now();
        }
        if (this.packetLastReceiveTime[packetId] <= oldEnoughTime) {
          // Failed to receive a packet
          timeDiff = oldEnoughTime - this.packetLastReceiveTime[packetId];
          logger.warn(`dropped packet ${packetId}: ${timeDiff} ms late`);
          isDoneSomething = true;
          if (this.bufferedPackets[packetId] != null) {
            delete this.bufferedPackets[packetId];
          }
          if (this.processedPacketId === MAX_PACKET_ID) {
            this.processedPacketId = 0;
          } else {
            this.processedPacketId++;
          }
        } else {
          break;
        }
      }
      if (isDoneSomething) {
        if (this.processedPacketId === MAX_PACKET_ID) {
          nextPacketId = 0;
        } else {
          nextPacketId = this.processedPacketId + 1;
        }
        this.consumeBufferedPacketsFrom(nextPacketId);
      }
    }

    onReceivePacket(packet) {
      var anticipatingPacketId, nextPacketId, ref;
      anticipatingPacketId = this.processedPacketId + 1;
      if (anticipatingPacketId === MAX_PACKET_ID + 1) {
        anticipatingPacketId = 0;
      }
      if (packet.packetId === anticipatingPacketId) {
        // continuous
        this.processedPacketId = packet.packetId;
        this.onCompletePacket(packet);
        if (packet.packetId === MAX_PACKET_ID) {
          nextPacketId = 0;
        } else {
          nextPacketId = packet.packetId + 1;
        }
        return this.consumeBufferedPacketsFrom(nextPacketId); // non-continuous
      } else {
        if (
          this.processedPacketId - RECEIVE_PACKET_ID_WINDOW <=
            (ref = packet.packetId) &&
          ref <= this.processedPacketId
        ) {
          logger.warn(`duplicated packet ${packet.packetId}`);
          if (packet.packetType === PACKET_TYPE_REQUIRE_ACK) {
            this.sendAck(packet.packetId, packet.port, packet.address);
          }
          return;
        }
        this.bufferedPackets[packet.packetId] = packet;
        return this.deleteOldBufferedPackets();
      }
    }

    onCompletePacket(packet) {
      if (packet.packetType === PACKET_TYPE_REQUIRE_ACK) {
        this.sendAck(packet.packetId, packet.port, packet.address);
      }
      return setTimeout(() => {
        return this.emit("packet", packet.body, packet.address, packet.port);
      }, 0);
    }

    sendAck(packetId, port, address, callback) {
      var buf;
      buf = Buffer.from([
        // packet type
        PACKET_TYPE_ACK,
        // packet id
        packetId
      ]);
      return this.socket.send(buf, 0, buf.length, port, address, callback);
    }

    start(port, address, callback) {
      return this.socket.bind(port, address, callback);
    }

    stop() {
      this.isStopped = true;
      return this.socket.close();
    }
  };
}.call(this));
