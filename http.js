// Generated by CoffeeScript 2.5.1
(function() {
  var DAY_NAMES,
    DEFAULT_SERVER_NAME,
    DIRECTORY_INDEX_FILENAME,
    GZIP_SIZE_THRESHOLD,
    HTTPHandler,
    MONTH_NAMES,
    STATIC_DIR,
    Sequent,
    TEMPLATE_DIR,
    api,
    ejs,
    fs,
    logger,
    path,
    spawn,
    zeropad,
    zlib;

  ejs = require("ejs");

  path = require("path");

  fs = require("fs");

  zlib = require("zlib");

  spawn = require("child_process").spawn;

  Sequent = require("sequent");

  logger = require("./logger");

  // Directory to store EJS templates
  TEMPLATE_DIR = `${__dirname}/template`;

  // Directory to store static files
  STATIC_DIR = `${__dirname}/public`;

  // Filename of default file in static directory
  DIRECTORY_INDEX_FILENAME = "index.html";

  // Server name which is embedded in HTTP response header
  DEFAULT_SERVER_NAME = "node-rtsp-rtmp-server";

  // Response larger than this bytes is compressed
  GZIP_SIZE_THRESHOLD = 300;

  DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

  MONTH_NAMES = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];

  zeropad = function(width, num) {
    num += "";
    while (num.length < width) {
      num = "0" + num;
    }
    return num;
  };

  HTTPHandler = class HTTPHandler {
    constructor(opts) {
      this.recordedDir = opts.recordedDir;
      this.rtspBase = opts.rtspBase;
      var ref, ref1;
      this.serverName =
        (ref = opts != null ? opts.serverName : void 0) != null
          ? ref
          : DEFAULT_SERVER_NAME;
      this.documentRoot =
        (ref1 = opts != null ? opts.documentRoot : void 0) != null
          ? ref1
          : STATIC_DIR;
    }

    setServerName(name) {
      return (this.serverName = name);
    }

    readFiles(file) {
      return fs
        .readdirSync(file)
        .filter(file => file.endsWith(".mp4"))
        .map(file => `${this.rtspBase}/${file}`);
    }

    handlePath(filepath, req, callback) {
      var opts;
      // Example implementation
      if (filepath === "/crossdomain.xml") {
        return this.respondCrossDomainXML(req, callback);
      } else if (filepath === "/ping") {
        return this.respondText("pong", req, callback);
      } else if (filepath === "/list") {
        opts = {
          files: this.readFiles(this.recordedDir)
        };
        return fs.readFile(
          `${TEMPLATE_DIR}/list.ejs`,
          {
            encoding: "utf8"
          },
          (err, template) => {
            var html;
            if (err) {
              logger.error(err);
              return this.serverError(req, callback);
            } else {
              html = ejs.render(template, opts);
              return this.respondHTML(html, req, callback);
            }
          }
        );
      } else if (filepath === "/302") {
        return this.redirect("/new-url", req, callback);
      } else if (filepath === "/404") {
        return this.notFound(req, callback);
      } else if (filepath === "/400") {
        return this.badRequest(req, callback);
      } else if (filepath === "/500") {
        return this.serverError(req, callback);
      } else {
        return this.respondStaticPath(
          `${this.documentRoot}/${filepath.slice(1)}`,
          req,
          callback
        );
      }
    }

    createHeader(params) {
      var header, protocol, ref, ref1, ref2, statusMessage;
      protocol = (ref = params.protocol) != null ? ref : "HTTP/1.1";
      statusMessage = "200 OK";
      if ((params != null ? params.statusCode : void 0) != null) {
        if (params.statusCode === 404) {
          statusMessage = "404 Not Found";
        } else if (params.statusCode === 500) {
          statusMessage = "500 Internal Server Error";
        } else if (params.statusCode === 302) {
          statusMessage = "302 Found";
        } else if (params.statusCode === 301) {
          statusMessage = "301 Moved Permanently";
        } else if (params.statusCode === 206) {
          statusMessage = "206 Partial Content";
        } else if (params.statusCode === 400) {
          statusMessage = "400 Bad Request";
        } else if (params.statusCode === 401) {
          statusMessage = "401 Unauthorized";
        }
      }
      header = `${protocol} ${statusMessage}
Date: ${api.getDateHeader()}
Server: ${this.serverName}
`;
      if (
        (params != null
          ? (ref1 = params.req) != null
            ? (ref2 = ref1.headers.connection) != null
              ? ref2.toLowerCase()
              : void 0
            : void 0
          : void 0) === "keep-alive"
      ) {
        header += "Connection: keep-alive\n";
      } else {
        header += "Connection: close\n";
      }
      if ((params != null ? params.contentLength : void 0) != null) {
        header += `Content-Length: ${params.contentLength}\n`;
      }
      if ((params != null ? params.location : void 0) != null) {
        header += `Location: ${params.location}\n`;
      }
      if ((params != null ? params.contentType : void 0) != null) {
        header += `Content-Type: ${params.contentType}\n`;
      }
      if ((params != null ? params.contentEncoding : void 0) != null) {
        header += `Content-Encoding: ${params.contentEncoding}\n`;
      }
      if ((params != null ? params.contentRange : void 0) != null) {
        header += `Content-Range: ${params.contentRange}\n`;
      }
      if ((params != null ? params.authenticate : void 0) != null) {
        header += `WWW-Authenticate: ${params.authenticate}\n`;
      }
      return header.replace(/\n/g, "\r\n") + "\r\n";
    }

    redirect(path, req, callback) {
      var headerBytes;
      headerBytes = Buffer.from(
        this.createHeader({
          statusCode: 302,
          location: path,
          req: req,
          contentLength: 0
        })
      );
      return callback(null, headerBytes);
    }

    notFound(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = Buffer.from("Not Found", "utf8");
      bodyLength = bodyBytes.length;
      headerBytes = Buffer.from(
        this.createHeader({
          statusCode: 404,
          contentLength: bodyLength,
          req: req,
          contentType: "text/plain; charset=utf-8"
        }),
        "utf8"
      );
      allBytes = Buffer.concat(
        [headerBytes, bodyBytes],
        headerBytes.length + bodyLength
      );
      return callback(null, allBytes);
    }

    respondTextWithHeader(str, req, opts, callback) {
      var allBytes, headerBytes, headerOpts, name, textBytes, textLength, value;
      textBytes = Buffer.from(str + "", "utf8");
      textLength = textBytes.length;
      headerOpts = {
        statusCode: 200,
        contentLength: textLength,
        req: req,
        contentType: "text/plain; charset=utf-8"
      };
      if (opts != null) {
        for (name in opts) {
          value = opts[name];
          headerOpts[name] = value;
        }
      }
      headerBytes = Buffer.from(this.createHeader(headerOpts), "utf8");
      allBytes = Buffer.concat(
        [headerBytes, textBytes],
        headerBytes.length + textLength
      );
      return callback(null, allBytes);
    }

    respondJavaScript(str, req, callback) {
      return this.respondTextWithHeader(
        str,
        req,
        {
          contentType: "application/javascript; charset=utf-8"
        },
        callback
      );
    }

    respondText(str, req, callback) {
      return this.respondTextWithHeader(str, req, null, callback);
    }

    treatCompress(bytes, req, callback) {
      var acceptEncoding;
      if (bytes.length < GZIP_SIZE_THRESHOLD) {
        callback(null, bytes, null);
        return;
      }
      acceptEncoding = req.headers["accept-encoding"];
      if (acceptEncoding == null) {
        callback(null, bytes, null);
        return;
      }
      acceptEncoding = acceptEncoding.toLowerCase();
      if (/\bgzip\b/.test(acceptEncoding)) {
        return zlib.gzip(bytes, function(err, compressedBytes) {
          if (err) {
            callback(err);
          } else {
            callback(null, compressedBytes, "gzip");
          }
        });
      } else if (/\bdeflate\b/.test(acceptEncoding)) {
        return zlib.deflate(bytes, function(err, compressedBytes) {
          if (err) {
            return callback(err);
          } else {
            return callback(null, compressedBytes, "deflate");
          }
        });
      } else {
        return callback(null, bytes, null);
      }
    }

    respondJS(content, req, callback) {
      var contentBytes;
      contentBytes = Buffer.from(content, "utf8");
      return this.treatCompress(
        contentBytes,
        req,
        (err, contentBytes, encoding) => {
          var allBytes, contentLength, headerBytes;
          if (err) {
            callback(err);
            return;
          }
          contentLength = contentBytes.length;
          headerBytes = Buffer.from(
            this.createHeader({
              contentLength: contentLength,
              req: req,
              contentEncoding: encoding,
              contentType: "application/javascript"
            }),
            "utf8"
          );
          allBytes = Buffer.concat(
            [headerBytes, contentBytes],
            headerBytes.length + contentLength
          );
          return callback(null, allBytes);
        }
      );
    }

    respondHTML(html, req, callback) {
      var htmlBytes;
      htmlBytes = Buffer.from(html, "utf8");
      return this.treatCompress(htmlBytes, req, (err, htmlBytes, encoding) => {
        var allBytes, headerBytes, htmlLength;
        if (err) {
          callback(err);
          return;
        }
        htmlLength = htmlBytes.length;
        headerBytes = Buffer.from(
          this.createHeader({
            contentLength: htmlLength,
            req: req,
            contentEncoding: encoding,
            contentType: "text/html; charset=utf-8"
          }),
          "utf8"
        );
        allBytes = Buffer.concat(
          [headerBytes, htmlBytes],
          headerBytes.length + htmlLength
        );
        return callback(null, allBytes);
      });
    }

    badRequest(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = Buffer.from("Bad Request", "utf8");
      bodyLength = bodyBytes.length;
      headerBytes = Buffer.from(
        this.createHeader({
          statusCode: 400,
          contentLength: bodyLength,
          req: req,
          contentType: "text/plain; charset=utf-8"
        }),
        "utf8"
      );
      allBytes = Buffer.concat(
        [headerBytes, bodyBytes],
        headerBytes.length + bodyLength
      );
      return callback(null, allBytes);
    }

    serverError(req, callback) {
      var allBytes, bodyBytes, bodyLength, headerBytes;
      bodyBytes = Buffer.from("Server Error", "utf8");
      bodyLength = bodyBytes.length;
      headerBytes = Buffer.from(
        this.createHeader({
          statusCode: 500,
          contentLength: bodyLength,
          req: req,
          contentType: "text/plain; charset=utf-8"
        }),
        "utf8"
      );
      allBytes = Buffer.concat(
        [headerBytes, bodyBytes],
        headerBytes.length + bodyLength
      );
      return callback(null, allBytes);
    }

    respondCrossDomainXML(req, callback) {
      var content, opts;
      content = `<?xml version="1.0"?>
<!DOCTYPE cross-domain-policy SYSTEM "http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">
<cross-domain-policy>
    <site-control permitted-cross-domain-policies="all"/>
    <allow-access-from domain="*" secure="false"/>
    <allow-http-request-headers-from domain="*" headers="*" secure="false"/>
</cross-domain-policy>
`;
      opts = {
        contentType: "text/x-cross-domain-policy"
      };
      return this.respondTextWithHeader(content, req, opts, callback);
    }

    respondStaticPath(filepath, req, callback) {
      if (filepath === "") {
        filepath = DIRECTORY_INDEX_FILENAME;
      } else if (/\/$/.test(filepath)) {
        filepath += DIRECTORY_INDEX_FILENAME;
      }
      if (filepath.indexOf("..") !== -1) {
        this.badRequest(req, callback);
        return;
      }
      return this.respondFile(filepath, req, callback);
    }

    respondFile(filepath, req, callback) {
      return fs.exists(filepath, exists => {
        if (exists) {
          return fs.stat(filepath, (err, stat) => {
            var seq;
            if (err) {
              logger.error(`stat error: ${filepath}`);
              this.serverError(req, callback);
              return;
            }
            seq = new Sequent();
            if (stat.isDirectory()) {
              filepath += `/${DIRECTORY_INDEX_FILENAME}`;
              fs.exists(filepath, exists => {
                if (exists) {
                  return seq.done();
                } else {
                  return this.notFound(req, callback);
                }
              });
            } else {
              seq.done();
            }
            return seq.wait(1, () => {
              return fs.readFile(
                filepath,
                {
                  encoding: null,
                  flag: "r"
                },
                (err, contentBuf) => {
                  var contentRangeHeader,
                    contentType,
                    doCompress,
                    from,
                    header,
                    headerBuf,
                    match,
                    statusCode,
                    to;
                  if (err) {
                    logger.error(`readFile error: ${filepath}`);
                    this.serverError(req, callback);
                    return;
                  }
                  contentRangeHeader = null;
                  if (req.headers.range != null) {
                    if (
                      (match = /^bytes=(\d+)?-(\d+)?$/.exec(
                        req.headers.range
                      )) != null
                    ) {
                      from = match[1] != null ? parseInt(match[1]) : null;
                      to = match[2] != null ? parseInt(match[2]) : null;
                      logger.debug(`Range from ${from} to ${to}`);
                      if (from == null && to != null) {
                        // last n bytes
                        contentRangeHeader = `bytes ${contentBuf.length -
                          to}-${contentBuf.length - 1}/${contentBuf.length}`;
                        contentBuf = contentBuf.slice(
                          contentBuf.length - to,
                          contentBuf.length
                        );
                      } else if (from != null && to == null) {
                        if (from > 0) {
                          contentRangeHeader = `bytes ${from}-${contentBuf.length -
                            1}/${contentBuf.length}`;
                          contentBuf = contentBuf.slice(
                            from,
                            contentBuf.length
                          );
                        }
                      } else if (from != null && to != null) {
                        contentRangeHeader = `bytes ${from}-${to}/${contentBuf.length}`;
                        contentBuf = contentBuf.slice(from, to + 1);
                      }
                    } else {
                      logger.error(
                        `[Range spec ${req.headers.range} is not supported]`
                      );
                    }
                  }
                  if (err) {
                    this.serverError(req, callback);
                    return;
                  }
                  contentType = "text/html; charset=utf-8";
                  doCompress = true;
                  if (/\.m3u8$/.test(filepath)) {
                    contentType = "application/x-mpegURL";
                  } else if (/\.ts$/.test(filepath)) {
                    contentType = "video/MP2T";
                    doCompress = false;
                  } else if (/\.mp4$/.test(filepath)) {
                    contentType = "video/mp4";
                    doCompress = false;
                  } else if (/\.3gpp?$/.test(filepath)) {
                    contentType = "video/3gpp";
                    doCompress = false;
                  } else if (/\.jpg$/.test(filepath)) {
                    contentType = "image/jpeg";
                    doCompress = false;
                  } else if (/\.gif$/.test(filepath)) {
                    contentType = "image/gif";
                    doCompress = false;
                  } else if (/\.png$/.test(filepath)) {
                    contentType = "image/png";
                    doCompress = false;
                  } else if (/\.swf$/.test(filepath)) {
                    contentType = "application/x-shockwave-flash";
                    doCompress = false;
                  } else if (/\.css$/.test(filepath)) {
                    contentType = "text/css";
                  } else if (/\.js$/.test(filepath)) {
                    contentType = "application/javascript";
                  } else if (/\.txt$/.test(filepath)) {
                    contentType = "text/plain; charset=utf-8";
                  }
                  if (contentRangeHeader != null) {
                    statusCode = 206;
                  } else {
                    statusCode = 200;
                  }
                  if (doCompress) {
                    return this.treatCompress(
                      contentBuf,
                      req,
                      (err, compressedBytes, encoding) => {
                        var header, headerBuf;
                        if (err) {
                          callback(err);
                          return;
                        }
                        header = this.createHeader({
                          statusCode: statusCode,
                          contentType: contentType,
                          contentLength: compressedBytes.length,
                          req: req,
                          contentRange: contentRangeHeader,
                          contentEncoding: encoding
                        });
                        headerBuf = Buffer.from(header, "utf8");
                        return callback(null, [headerBuf, compressedBytes]);
                      }
                    );
                  } else {
                    header = this.createHeader({
                      statusCode: statusCode,
                      contentType: contentType,
                      contentLength: contentBuf.length,
                      req: req,
                      contentRange: contentRangeHeader
                    });
                    headerBuf = Buffer.from(header, "utf8");
                    return callback(null, [headerBuf, contentBuf]);
                  }
                }
              );
            });
          });
        } else {
          logger.warn(`[http] Requested file not found: ${filepath}`);
          return this.notFound(req, callback);
        }
      });
    }
  };

  api = {
    HTTPHandler: HTTPHandler,
    getDateHeader: function() {
      var d;
      d = new Date();
      return (
        `${DAY_NAMES[d.getUTCDay()]}, ${d.getUTCDate()} ${
          MONTH_NAMES[d.getUTCMonth()]
        }` +
        ` ${d.getUTCFullYear()} ${zeropad(2, d.getUTCHours())}:${zeropad(
          2,
          d.getUTCMinutes()
        )}` +
        `:${zeropad(2, d.getUTCSeconds())} UTC`
      );
    },
    parseRequest: function(str) {
      var body,
        decodedURI,
        e,
        headerPart,
        headers,
        i,
        j,
        len,
        line,
        lines,
        method,
        params,
        protocol,
        protocolName,
        protocolVersion,
        slashPos,
        uri;
      [headerPart, body] = str.split("\r\n\r\n");
      lines = headerPart.split(/\r\n/);
      [method, uri, protocol] = lines[0].split(/\s+/);
      if (protocol != null) {
        // Split "HTTP/1.1" to "HTTP" and "1.1"
        slashPos = protocol.indexOf("/");
        if (slashPos !== -1) {
          protocolName = protocol.slice(0, slashPos);
          protocolVersion = protocol.slice(slashPos + 1);
        }
      }
      headers = {};
      for (i = j = 0, len = lines.length; j < len; i = ++j) {
        line = lines[i];
        if (i === 0) {
          continue;
        }
        if (/^\s*$/.test(line)) {
          continue;
        }
        params = line.split(": ");
        headers[params[0].toLowerCase()] = params[1];
      }
      try {
        decodedURI = decodeURIComponent(uri);
      } catch (error) {
        e = error;
        logger.error(`error: failed to decode URI: ${uri}`);
        return null;
      }
      return {
        method: method,
        uri: decodedURI,
        protocol: protocol,
        protocolName: protocolName,
        protocolVersion: protocolVersion,
        headers: headers,
        body: body,
        headerBytes: Buffer.byteLength(headerPart, "utf8")
      };
    }
  };

  module.exports = api;
}.call(this));
